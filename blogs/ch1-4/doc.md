# HKOS

## 系统引导MBR

MBR（Master Boot Record），即主引导记录。
计算机开机后，IP指针指向BIOS内存地址区域，BIOS进行初始化等操作，然后直接将硬盘的第一扇区，即C/H/S地址的0柱面0磁头1扇区中512字节大小的MBR载入到以0X7C00为首地址的内存中，并且开始执行。自此开始，BIOS失去了对计算机的控制权，所有的控制权都交给了MBR以及今后将要编写的所有程序。

以上提到的“第一扇区”，“512字节”，“0X7C00”都是约定俗成的魔数"magic number"，是写死的，不能改变的。顺便值得一提的是，MBR的最后两个字节从低到高固定为 0x55 0xaa

在本系统中的MBR主要使用IO端口编程实现磁盘访问。因为MBR只有固定512字节，所以很多事情不能在MBR中完成，因此需要一个不限制大小的程序来完成相关事务，因此MBR的还有一个功能就是将存在于磁盘的那个更加强大的程序载入内存，并且将控制权交给那个更加强大的程序。在本系统中，那个更加强大的程序称为loader。我们也需要与MBR约定，loader在磁盘中的哪个位置，又应该载入到内存的哪个地址，这是MBR与loader作的约定，好比BIOS与MBR作的约定。


## 系统加载器loader

loader，是一个强大的程序，该程序将会完成很多初始化任务。包括但不限于，开启分页，进入保护模式，填写全局描述符表，以及将控制权交给内核程序，即操作系统本身。

### 保护模式简析

再保护模式之前，CPU内部没有权限管理，因此造成任何程序的权限都与操作系统平起平坐，用户程序可以随意破坏和修改操作系统，甚至损坏硬件。随着计算机的普及，计算机不在仅仅用作科学计算，而是走入了千家万户。因为计算机用户不一定全部具备专业知识，所以在使用的过程中很有可能造成灾难性的后果。也因为网络的发展，不断的有黑客的攻击，导致很多计算机处于危险中。因此，保护模式诞生了。保护模式，顾名思义，就是为了保护计算机。在保护模式中，有严格的硬件保障的权限机制。很多操作用户不能够进行，需要操作系统代理进行操作。因此操作系统开发者完全可以限制用户的操作。黑客在某种意义上也是操作系统的用户，因此也限制了黑客病毒的攻击。这大大得提高了计算机系统的安全性。

在MBR和部分loader代码中，系统还并未处于保护模式。因此进入保护模式，只需要按下某个开关即可进入保护模式。这个开关就是CR0寄存器的PE位置置1，即可进入保护模式。

学过8086汇编的同学都知道，在8086汇编中编程，访问一个内存地址要分两步走。
+ 第一步是给出段寄存器，段寄存器存储段基址。
+ 第二步是给出段内偏移量。
+ 第三步是将（段基址*16（左移4位） + 段内偏移量）以获取20位地址，然后定位到内存，再取数据或者存数据。


在保护模式中，也采用段基址：偏移量的方式进行内存访问。但不同的是，在保护模式，为每个段赋予了一些控制属性。聪明的你可能猜到了，保护模式中保护的实现就在这个段中实现。
众所周知，单核CPU只有一个CS寄存器以及一个IP寄存器。所以CS寄存器中的值表示当前所在的段，IP寄存器表示偏移量。
保护模式应用于32位CPU,因此CPU中的大部分寄存器都是32位。但是CS寄存器并不是，依旧是16位。因此16位的寄存器不能表示段基址，那么该如何让CS寄存器来表示段基址呢?

我们在编程的过程中，可能会遇到用一个数组存储某些东西的情况。访问一个数组，我们需要数组的开始地址，以及数组的偏移量。这么做就可以定位到数组元素了。那么我们不妨想一想，能否在内存中维护一个数组，用于存放段基址呢？完全是可以的。那么聪明的你可能想到了，这个偏移量就是CS寄存器中的值。

所以在保护模式中访问段基址的方式如下：
+ 第一步，获取段基址数组的起始地址
+ 第二步，获取段基址数组的偏移量，即CS寄存器中的值
+ 第三步，定位内存地址获取段基址

还有一个问题，每次访问内存如果都需要先访问一遍段基址数组获取元素再得到段基址，会显得非常没有效率。因此为了解决这个问题，段基址在获取后会存在于一个特殊的32位寄存器中，以后每次访问段基址就直接去这里面找就可以了。当然，如果要改用其他的段基址，那也需要按照访问数组的方式重新来一遍获取段基址，再更新特殊的32位寄存器即可。

那么保护体现在哪里呢？保护就体现在这个段基址数组中的每个元素的属性中。这个数组元素不仅仅包含段基址，还包含了一些控制信息。所以这个不仅仅是单纯的数组，而是一个结构体数组。我们知道，访问内存形式依旧是DS:OFFSET形式，因此完全可以通过当前CS所指向的段基址中的权限信息与DS所指向的段基址中的权限信息比较，如果CS权限大于DS，那么就可以直接访问DS:OFFSET中的内存并且读取或者修改。

同样的，如果要改变CS寄存器，我们需要获取其他段基址，只要将当前CS所指向的段基址与目标段基址中的权限进行比较即可，不过对于CS代码段特殊的是，只有平级才能转移，无论是高还是低都不能转移。

权限从小变成大，需要借助一些工具，（形象的类比就是蹦床）。
但是权限从大变为小，只有一种方式，那就是函数返回或者中断返回方式。


